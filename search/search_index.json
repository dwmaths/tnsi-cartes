{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jeux de cartes","text":""},{"location":"#modelisation","title":"Mod\u00e9lisation","text":"<p>Une carte est un objet de la vie courante qui poss\u00e8de deux caract\u00e9ristiques :</p> <ul> <li>une couleur parmi : Carreau, Coeur, Pique, Tr\u00e8fle ;</li> <li>une valeur parmi : 7, 8, 9, 10, V, D, R, As ;</li> </ul> <p> </p> <p>On pourrait ais\u00e9ment repr\u00e9senter une carte \u00e0 l'aide d'un tuple nomm\u00e9 ou encore d'un dictionnaire mais on d\u00e9cide de coder chacune de ces cartes \u00e0 l'aide d'un entier. Pour associer un entier \u00e0 une carte (en gardant une certaine coh\u00e9rence), on d\u00e9cide d'utiliser un mot binaire.</p>"},{"location":"#mot-binaire","title":"Mot binaire0bCCVVV","text":"<p>On commence par rappeler quelques d\u00e9tails techniques en Python :</p> <p>Quelques op\u00e9rateurs binaires</p> <ol> <li> <p>\u00c9crire l'instruction <code>a = 0b10010110</code> et v\u00e9rifier qu'il est bien \u00e9gal \u00e0 <code>150</code>.</p> Note <p>On rappelle que \\(a = 1\\times 2^1 + 1\\times 2^2 + 1\\times 2^4 + 1\\times 2^7 = 150\\).</p> </li> <li> <p>Si on souhaite r\u00e9cup\u00e9rer les quatre bits de poids faibles, on effectue un ET LOGIQUE comme dans l'instruction <code>a &amp; 0b00001111</code>. Tester cette instruction et v\u00e9rifier que l'on obtient <code>6</code></p> Note <p>Si on \u00e9crit <code>6</code> en binaire (\u00e0 l'aide de l'instruction <code>bin(6)</code>), on obtient <code>0b110</code> que l'on peut aussi \u00e9crire <code>0b0110</code>.</p> </li> <li> <p>V\u00e9rifier que l'instruction <code>a &amp; 240</code> renvoie le nombre <code>144</code> et essayer de comprendre pourquoi.</p> Indication <p>Peut-\u00eatre faudrait-il convertir <code>240</code> en binaire pour comprendre.</p> Attention <p>En r\u00e9alit\u00e9, on n'obtient pas les quatre bits de poids forts ici. En effet, le mot est compl\u00e9t\u00e9 par quatre z\u00e9ros. Pour supprimer ces quatre z\u00e9ros, il faut d\u00e9caler le mot obtenu de quatre bits vers la droite.  </p> <p>Tester l'instruction <code>144 &gt;&gt; 4</code> et v\u00e9rifier qu'en binaire le r\u00e9sultat s'\u00e9crit <code>0b1001</code>.</p> </li> <li> <p>V\u00e9rifier que l'instruction <code>0b1001 &lt;&lt; 4 | 0b0110</code> permet de retrouver le nombre de d\u00e9part.</p> Note <p>L'op\u00e9rateur <code>|</code> est un OU LOGIQUE.</p> </li> </ol> <p>Pour mod\u00e9liser une carte, il nous faut donc :</p> <ul> <li>une couleur (parmi quatre possibles) ;</li> <li>une valeur (parmi huit possibles).</li> </ul> <p>On utilise alors un mot binaire de la forme </p> <p> <p></p> <p>car il nous faut 2 bits pour la couleur (\\(2^2 = 4\\)) et 3 bits pour la valeur (\\(2^3 = 8\\)).  </p> <p>On d\u00e9cide alors des correspondances entre mot binaire et couleur de carte avec le tableau :</p> Couleur Carreau Coeur Pique Tr\u00e8fle Binaire 00 01 10 11 <p>De la m\u00eame fa\u00e7on, on d\u00e9cide de l'association pour les valeurs :</p> Valeur 7 8 9 10 V D R As Binaire 000 001 010 011 100 101 110 111 <p>Pour commencer, vous \u00eates invit\u00e9 \u00e0 t\u00e9l\u00e9charger le fichier  cartes.py.</p> <p>Implantation</p> <ol> <li> <p>Implanter la fonction <code>creer_carte(c:int, v:int) -&gt; int</code> qui renvoie l'entier dont l'\u00e9criture en binaire correspond au mod\u00e8le choisi ci-dessus.</p> Indications <p>M\u00eame si les variables <code>c</code> et <code>v</code> sont des entiers, on peut leur appliquer des op\u00e9rations binaires. Attention, il faudra d\u00e9caler des bits vers la gauche cette fois !</p> </li> <li> <p>Implanter les fonctions <code>couleur(carte:int) -&gt; int</code> et <code>valeur(carte:int) -&gt; int</code> qui renvoient respectivement la couleur et la valeur de la carte.</p> Indications <p>C'est le moment d'appliquer des masques et de faire des d\u00e9calages de bits !</p> </li> <li> <p>Tester alors l'instruction <code>voir_carte(14)</code> qui doit renvoyer <code>\"Roi de \u2665\"</code>.</p> </li> </ol> Correction <ol> <li> <p>On propose la fonction :</p> Cr\u00e9ation d'une carte<pre><code>def creer_carte(c:int, v:int) -&gt; int:\n    \"\"\"\n        Cr\u00e9e une carte de couleur c et de valeur v.\n    \"\"\"\n    return (c &lt;&lt; 3) | v\n</code></pre> </li> <li> <p>On propose :</p> Couleur d'une carte<pre><code>def couleur(carte:int) -&gt; int:\n    \"\"\"\n        Renvoie la couleur d'une carte.\n    \"\"\"\n    return (carte &amp; 0b11000) &gt;&gt; 3\n</code></pre> <p>et aussi </p> Valeur d'une carte<pre><code>def valeur(carte:int) -&gt; int:\n    \"\"\"\n        Renvoie la valeur d'une carte.\n    \"\"\"\n    return carte &amp; 0b00111\n</code></pre> </li> </ol>"},{"location":"#melange-et-distribution","title":"M\u00e9lange et distribution","text":"<p>Vous avez pu constater la pr\u00e9sence de la fonction <code>creer_jeu() -&gt; list</code> qui permet de r\u00e9cup\u00e9rer la liste compl\u00e8te de toutes les cartes d'un jeu. Vous pouvez d'ailleurs tester l'instruction <code>L = creer_jeu()</code> et ensuite jouer avec la fonction <code>voir_carte(carte:int) -&gt; str</code> pour observer cette liste.  </p> <p>Par exemple, l'instruction <code>[voir_carte(k) for k in range(8)]</code> montre les carreaux.</p> <p>\u00c0 pr\u00e9sent, vous \u00eates invit\u00e9 \u00e0 t\u00e9l\u00e9charger le fichier  gestion.py.</p> <p>Gestion d'un jeu</p> <ol> <li> <p>Pour implanter la fonction <code>melanger_jeu(jeu:list) -&gt; None</code>, on propose l'algorithme suivant :</p> M\u00e9lange d'un jeu<pre><code>Pour chaque carte de la liste\n\n    \u00e9changer cette carte avec une autre choisie al\u00e9atoirement.\n</code></pre> Indication <p>N'oubliez pas d'importer la fonction <code>randrange</code> du module <code>random</code>.</p> </li> <li> <p>On s'int\u00e9resse \u00e0 pr\u00e9sent \u00e0 la distribution des cartes. Pour cela, on cherche \u00e0 implanter la fonction <code>distribution(jeu:list, nbj:int, nbc:int) -&gt; dict</code>.</p> <p>a. Il n'est pas possible de distribuer les cartes quand il n'y en a pas assez. Compl\u00e9ter le d\u00e9but du code pour g\u00e9rer cette contrainte.</p> <p>b. La fonction doit renvoyer un dictionnaire de la forme :</p> Dictionnaire des joueurs<pre><code>{ \"Joueur 1\" : [...],\n  \"Joueur 2\" : [...],\n  \"Joueur 3\" : [...], ... }\n</code></pre> <p>Compl\u00e9ter le code propos\u00e9.</p> Indication <p>Pour retirer le premier \u00e9l\u00e9ment d'une liste <code>L</code>, on peut utiliser l'instruction <code>L.pop(0)</code>.</p> </li> <li> <p>Tester les instructions suivantes :</p> Observations<pre><code>&gt;&gt;&gt; jeu = creer_jeu()\n&gt;&gt;&gt; melanger_jeu(jeu)\n&gt;&gt;&gt; joueurs = distribution(jeu, 4, 5)\n&gt;&gt;&gt; voir_mains(joueurs)\n</code></pre> </li> </ol> Correction <ol> <li> <p>On propose le code :</p> M\u00e9lange d'un jeu<pre><code>from random import randrange\n\ndef melanger_jeu(jeu:list) -&gt; None:\n    \"\"\"\n        M\u00e9lange le jeu inplace.\n    \"\"\"\n    n = len(jeu)\n    for i in range(n):\n        j = randrange(0, n)\n        L[i], L[j] = L[j], L[i]\n</code></pre> </li> <li> <p>On propose le code :</p> Distribution entre les joueurs<pre><code>def distribution(jeu:list, nbj:int, nbc:int) -&gt; dict:\n    \"\"\"\n        jeu : la liste des cartes\n        nbj : le nombre de joueurs\n        nbc : le nombre de cartes par joueurs\n\n        Attention : la liste jeu doit se vider des cartes distribu\u00e9es.\n    \"\"\"\n    res = {} # Le dictionnaire des joueurs\n\n    if nbj*nbc &lt;= len(jeu) : # Il est possible de distribuer\n\n        for i in range(1, nbj+1): # On distribue joueur par joueur\n            res[f\"Joueur {i}\"] = [] # Jeu vide pour commencer\n\n            for j in range(nbc): # On distribue nbc cartes\n                res[f\"Joueur {i}\"].append(jeu.pop(0))\n\n    return res\n</code></pre> </li> </ol>"},{"location":"#trier-sa-main","title":"Trier sa main","text":"<p>Il est courant d'avoir \u00e0 trier ses cartes une fois re\u00e7ues. De fa\u00e7on habituelle, on commence souvent par :</p> <ul> <li>organiser ses cartes par couleur ;</li> <li>organiser ensuite ses cartes par valeur ;</li> </ul> <p>\u00c0 pr\u00e9sent, vous \u00eates invit\u00e9 \u00e0 t\u00e9l\u00e9charger le fichier  tris.py.</p> <p>Pour terminer</p> <ol> <li>Compl\u00e9ter la fonction permettant de comparer les cartes.</li> <li>Compl\u00e9ter la fonction permettant le tri par s\u00e9lection d'une main d'un joueur.</li> </ol>"}]}